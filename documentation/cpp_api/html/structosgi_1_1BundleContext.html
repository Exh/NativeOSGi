<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Native OSGi C++ API: osgi::BundleContext Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Native OSGi C++ API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structosgi_1_1BundleContext.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">osgi::BundleContext Struct Reference<div class="ingroups"><a class="el" href="group__cpp__api.html">API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A bundle's execution context within the framework.  
 <a href="structosgi_1_1BundleContext.html#details">More...</a></p>

<p><a href="structosgi_1_1BundleContext-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3171cf4700e41eae44882bfc1d71e96a"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#a3171cf4700e41eae44882bfc1d71e96a">getProperty</a> (const std::string &amp;key) const =0</td></tr>
<tr class="memdesc:a3171cf4700e41eae44882bfc1d71e96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the specified property.  <a href="#a3171cf4700e41eae44882bfc1d71e96a"></a><br/></td></tr>
<tr class="memitem:abe59b6310c208d4e5bbd2b695ce34246"><td class="memItemLeft" align="right" valign="top">virtual Bundle *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#abe59b6310c208d4e5bbd2b695ce34246">getBundle</a> () const =0</td></tr>
<tr class="memdesc:abe59b6310c208d4e5bbd2b695ce34246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>IBundle</code> object associated with this <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code>.  <a href="#abe59b6310c208d4e5bbd2b695ce34246"></a><br/></td></tr>
<tr class="memitem:aa9ad5fb869062ed85aff154fcd25e63e"><td class="memItemLeft" align="right" valign="top">virtual Bundle *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#aa9ad5fb869062ed85aff154fcd25e63e">installBundle</a> (const std::string &amp;location, std::istream *input=NULL)=0</td></tr>
<tr class="memdesc:aa9ad5fb869062ed85aff154fcd25e63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a bundle from the specified <code>std::istream</code> object.  <a href="#aa9ad5fb869062ed85aff154fcd25e63e"></a><br/></td></tr>
<tr class="memitem:a72291aae38791624b682038e50768a16"><td class="memItemLeft" align="right" valign="top">virtual Bundle *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#a72291aae38791624b682038e50768a16">getBundle</a> (long id) const =0</td></tr>
<tr class="memdesc:a72291aae38791624b682038e50768a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bundle with the specified identifier.  <a href="#a72291aae38791624b682038e50768a16"></a><br/></td></tr>
<tr class="memitem:a510548621888bb4b545fccfd8ba2f326"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; Bundle * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#a510548621888bb4b545fccfd8ba2f326">getBundles</a> () const =0</td></tr>
<tr class="memdesc:a510548621888bb4b545fccfd8ba2f326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all known modules.  <a href="#a510548621888bb4b545fccfd8ba2f326"></a><br/></td></tr>
<tr class="memitem:ac2a29655ce5f9a3b78193a1beb9b3cab"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; <a class="el" href="classosgi_1_1ServiceReference.html">ServiceReference</a>&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#ac2a29655ce5f9a3b78193a1beb9b3cab">getServiceReferences</a> (const std::string &amp;clazz, const std::string &amp;filter)=0</td></tr>
<tr class="memdesc:ac2a29655ce5f9a3b78193a1beb9b3cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of <code><a class="el" href="classosgi_1_1ServiceReferenceBase.html" title="A reference to a service.">ServiceReferenceBase</a></code> objects.  <a href="#ac2a29655ce5f9a3b78193a1beb9b3cab"></a><br/></td></tr>
<tr class="memitem:a4925e35fd2eb059fe7e35ae15a1802ad"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classosgi_1_1ServiceReference.html">ServiceReference</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#a4925e35fd2eb059fe7e35ae15a1802ad">getServiceReference</a> (const std::string &amp;clazz, bool cppOnly=true)=0</td></tr>
<tr class="memdesc:a4925e35fd2eb059fe7e35ae15a1802ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="classosgi_1_1ServiceReferenceBase.html" title="A reference to a service.">ServiceReferenceBase</a></code> object for a service that implements and was registered under the specified class.  <a href="#a4925e35fd2eb059fe7e35ae15a1802ad"></a><br/></td></tr>
<tr class="memitem:a2e036a67a3a0b85601f00abffa7ce84a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classosgi_1_1ServiceRegistrationBase.html">ServiceRegistrationBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#a2e036a67a3a0b85601f00abffa7ce84a">registerService</a> (const std::map&lt; std::string, void * &gt; &amp;service, bool isNativeCpp, const <a class="el" href="group__cpp__api.html#gab0aeecec02de2f46dd69e0cad120ee94">ServiceProperties</a> &amp;properties)=0</td></tr>
<tr class="memdesc:a2e036a67a3a0b85601f00abffa7ce84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the specified service object with the specified properties under the specified class names into the framework.  <a href="#a2e036a67a3a0b85601f00abffa7ce84a"></a><br/></td></tr>
<tr class="memitem:a715658d1655dd0a9ed089b7e3f095539"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:a715658d1655dd0a9ed089b7e3f095539"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classosgi_1_1ServiceRegistration.html">ServiceRegistration</a>&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#a715658d1655dd0a9ed089b7e3f095539">registerService</a> (S *service, const <a class="el" href="group__cpp__api.html#gab0aeecec02de2f46dd69e0cad120ee94">ServiceProperties</a> &amp;properties=<a class="el" href="group__cpp__api.html#gab0aeecec02de2f46dd69e0cad120ee94">ServiceProperties</a>())</td></tr>
<tr class="memdesc:a715658d1655dd0a9ed089b7e3f095539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the specified service object with the specified properties under the specified template argument type into the Framework.  <a href="#a715658d1655dd0a9ed089b7e3f095539"></a><br/></td></tr>
<tr class="memitem:ac99fb8a4ea2c745e52b430410b136494"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac99fb8a4ea2c745e52b430410b136494"></a>
template&lt;class S , class T &gt; </td></tr>
<tr class="memitem:ac99fb8a4ea2c745e52b430410b136494"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classosgi_1_1ServiceRegistration.html">ServiceRegistration</a>&lt; S, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>registerService</b> (S *srvIFace1, T *srvIFace2, const <a class="el" href="group__cpp__api.html#gab0aeecec02de2f46dd69e0cad120ee94">ServiceProperties</a> &amp;properties=<a class="el" href="group__cpp__api.html#gab0aeecec02de2f46dd69e0cad120ee94">ServiceProperties</a>())</td></tr>
<tr class="memitem:aa6326ddaefa00ea65495cd45694f408e"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:aa6326ddaefa00ea65495cd45694f408e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classosgi_1_1ServiceReference.html">ServiceReference</a><br class="typebreak"/>
&lt; S &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#aa6326ddaefa00ea65495cd45694f408e">getServiceReferences</a> (const std::string &amp;filter=std::string())</td></tr>
<tr class="memdesc:aa6326ddaefa00ea65495cd45694f408e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects.  <a href="#aa6326ddaefa00ea65495cd45694f408e"></a><br/></td></tr>
<tr class="memitem:ac7ecad76ec321f8eebd850cda36eedff"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:ac7ecad76ec321f8eebd850cda36eedff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classosgi_1_1ServiceReference.html">ServiceReference</a>&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#ac7ecad76ec321f8eebd850cda36eedff">getServiceReference</a> ()</td></tr>
<tr class="memdesc:ac7ecad76ec321f8eebd850cda36eedff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object for a service that implements and was registered under the specified type.  <a href="#ac7ecad76ec321f8eebd850cda36eedff"></a><br/></td></tr>
<tr class="memitem:ad4a9d783b04e42c0e960fefde434591b"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:ad4a9d783b04e42c0e960fefde434591b"><td class="memTemplItemLeft" align="right" valign="top">S *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#ad4a9d783b04e42c0e960fefde434591b">getService</a> (const <a class="el" href="classosgi_1_1ServiceReference.html">ServiceReference</a>&lt; S &gt; &amp;reference)</td></tr>
<tr class="memdesc:ad4a9d783b04e42c0e960fefde434591b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the service object referenced by the specified <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object.  <a href="#ad4a9d783b04e42c0e960fefde434591b"></a><br/></td></tr>
<tr class="memitem:ae551559d87c4f9231e12f85d3c5772d8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#ae551559d87c4f9231e12f85d3c5772d8">ungetService</a> (const <a class="el" href="classosgi_1_1ServiceReferenceBase.html">ServiceReferenceBase</a> &amp;reference) const =0</td></tr>
<tr class="memdesc:ae551559d87c4f9231e12f85d3c5772d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the service object referenced by the specified <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object.  <a href="#ae551559d87c4f9231e12f85d3c5772d8"></a><br/></td></tr>
<tr class="memitem:a524fcfd39d55cc2311c7420db8d5eb52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a524fcfd39d55cc2311c7420db8d5eb52"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addServiceListener</b> (const ServiceListener &amp;delegate, const std::string &amp;filter=std::string())=0</td></tr>
<tr class="memitem:a42736a330f505190d277dd00d7090ba7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42736a330f505190d277dd00d7090ba7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeServiceListener</b> (const ServiceListener &amp;delegate)=0</td></tr>
<tr class="memitem:a1a9206cd9a1affa522eb63ddfa64b471"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a9206cd9a1affa522eb63ddfa64b471"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addBundleListener</b> (const BundleListener &amp;delegate)=0</td></tr>
<tr class="memitem:a639977b8534f71d60cfbf9b01624eaad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a639977b8534f71d60cfbf9b01624eaad"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeBundleListener</b> (const BundleListener &amp;delegate)=0</td></tr>
<tr class="memitem:ad47aca3dbd73188548a188893b71533c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#ad47aca3dbd73188548a188893b71533c">addFrameworkListener</a> (const FrameworkListener &amp;listener)=0</td></tr>
<tr class="memdesc:ad47aca3dbd73188548a188893b71533c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified <code>FrameworkListener</code> object to the context bundle's list of listeners if not already present.  <a href="#ad47aca3dbd73188548a188893b71533c"></a><br/></td></tr>
<tr class="memitem:aba49128a2ccfdc0184b4ff5becb081d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#aba49128a2ccfdc0184b4ff5becb081d8">removeFrameworkListener</a> (const FrameworkListener &amp;listener)=0</td></tr>
<tr class="memdesc:aba49128a2ccfdc0184b4ff5becb081d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified <code>FrameworkListener</code> object from the context bundle's list of listeners.  <a href="#aba49128a2ccfdc0184b4ff5becb081d8"></a><br/></td></tr>
<tr class="memitem:a65442692af69428d5173a09f2ba62f4b"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:a65442692af69428d5173a09f2ba62f4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#a65442692af69428d5173a09f2ba62f4b">addServiceListener</a> (R *receiver, void(R::*callback)(const ServiceEvent), const std::string &amp;filter=std::string())</td></tr>
<tr class="memdesc:a65442692af69428d5173a09f2ba62f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified <code>callback</code> with the specified <code>filter</code> to the context modules's list of listeners.  <a href="#a65442692af69428d5173a09f2ba62f4b"></a><br/></td></tr>
<tr class="memitem:afd74b1d2f53e70de60ae67d5af474a93"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:afd74b1d2f53e70de60ae67d5af474a93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#afd74b1d2f53e70de60ae67d5af474a93">removeServiceListener</a> (R *receiver, void(R::*callback)(const ServiceEvent))</td></tr>
<tr class="memdesc:afd74b1d2f53e70de60ae67d5af474a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified <code>callback</code> from the context bundle's list of listeners.  <a href="#afd74b1d2f53e70de60ae67d5af474a93"></a><br/></td></tr>
<tr class="memitem:a4168773262b6a3313c930e701ab14919"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:a4168773262b6a3313c930e701ab14919"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#a4168773262b6a3313c930e701ab14919">addBundleListener</a> (R *receiver, void(R::*callback)(const BundleEvent))</td></tr>
<tr class="memdesc:a4168773262b6a3313c930e701ab14919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified <code>callback</code> to the context modules's list of listeners.  <a href="#a4168773262b6a3313c930e701ab14919"></a><br/></td></tr>
<tr class="memitem:a93e7f266d9edcf770a628ef79bdbc1a2"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:a93e7f266d9edcf770a628ef79bdbc1a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#a93e7f266d9edcf770a628ef79bdbc1a2">removeBundleListener</a> (R *receiver, void(R::*callback)(const BundleEvent))</td></tr>
<tr class="memdesc:a93e7f266d9edcf770a628ef79bdbc1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified <code>callback</code> from the context bundle's list of listeners.  <a href="#a93e7f266d9edcf770a628ef79bdbc1a2"></a><br/></td></tr>
<tr class="memitem:a51e9c32f19a4f8c9642813c3d6f278e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a51e9c32f19a4f8c9642813c3d6f278e4"></a>
template&lt;class R &gt; </td></tr>
<tr class="memitem:a51e9c32f19a4f8c9642813c3d6f278e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addFrameworkListener</b> (R *receiver, void(R::*callback)(const FrameworkEvent))</td></tr>
<tr class="memitem:a65d3f179ba2a1f32682ddd8a1ed3482c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a65d3f179ba2a1f32682ddd8a1ed3482c"></a>
template&lt;class R &gt; </td></tr>
<tr class="memitem:a65d3f179ba2a1f32682ddd8a1ed3482c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>removeFrameworkListener</b> (R *receiver, void(R::*callback)(const FrameworkEvent))</td></tr>
<tr class="memitem:aa8ee6af9a244fa2bfefa03efb9d4aba0"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#aa8ee6af9a244fa2bfefa03efb9d4aba0">getDataFile</a> (const std::string &amp;filename) const =0</td></tr>
<tr class="memdesc:aa8ee6af9a244fa2bfefa03efb9d4aba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string containing the location for a file in the persistent storage area provided for the bundle by the Framework.  <a href="#aa8ee6af9a244fa2bfefa03efb9d4aba0"></a><br/></td></tr>
<tr class="memitem:a30c73dd987bb80692247493bd5d264cf"><td class="memItemLeft" align="right" valign="top">virtual Filter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#a30c73dd987bb80692247493bd5d264cf">createFilter</a> (const std::string &amp;filter) const =0</td></tr>
<tr class="memdesc:a30c73dd987bb80692247493bd5d264cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>Filter</code> object.  <a href="#a30c73dd987bb80692247493bd5d264cf"></a><br/></td></tr>
<tr class="memitem:a50bad0aa626362bd9355a9755b5d6356"><td class="memItemLeft" align="right" valign="top">virtual Bundle *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structosgi_1_1BundleContext.html#a50bad0aa626362bd9355a9755b5d6356">getBundle</a> (const std::string &amp;location) const =0</td></tr>
<tr class="memdesc:a50bad0aa626362bd9355a9755b5d6356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bundle with the specified location.  <a href="#a50bad0aa626362bd9355a9755b5d6356"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A bundle's execution context within the framework. </p>
<p>The context is used to grant access to other methods so that this bundle can interact with the Framework.</p>
<p><code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code> methods allow a bundle to: </p>
<ul>
<li>
Subscribe to events published by the Framework. </li>
<li>
Register service objects with the Framework service registry. </li>
<li>
Retrieve <code>ServiceReferences</code> from the Framework service registry. </li>
<li>
Get and release service objects for a referenced service. </li>
<li>
Install new bundles in the Framework. </li>
<li>
Get the list of bundles installed in the Framework. </li>
<li>
Get the Bundle object for a bundle. </li>
<li>
Create <code>File</code> objects for files in a persistent storage area provided for the bundle by the Framework. </li>
</ul>
<p>A <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code> object will be created for a bundle when the bundle is started. The <code>Bundle</code> object associated with a <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code> object is called the <em>context bundle</em>.</p>
<p>The <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code> object will be passed to the <a class="el" href="">BundleActivator#start</a> method during activation of the context bundle. The same <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code> object will be passed to the <a class="el" href="">BundleActivator#stop</a> method when the context bundle is stopped. A <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code> object is generally for the private use of its associated bundle and is not meant to be shared with other bundles in the OSGi environment.</p>
<p>The <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code> object is only valid during the execution of its context bundle; that is, during the period from when the context bundle is in the <code>STARTING</code>, <code>STOPPING</code>, and <code>ACTIVE</code> bundle states. If the <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code> object is used subsequently, an <code>IllegalStateException</code> must be thrown. The <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code> object must never be reused after its context bundle is stopped.</p>
<p>Two <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code> objects are equal if they both refer to the same execution context of a bundle. The Framework is the only entity that can create <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code> objects and they are only valid within the Framework that created them.</p>
<p>A <a class="el" href="">Bundle</a> can be <a class="el" href="">adapted</a> to its <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code>.</p>
<dl class="section note"><dt>Note:</dt><dd>This class is thread-safe. </dd>
<dd>
This class is not intended to be implemented by clients. </dd></dl>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4168773262b6a3313c930e701ab14919"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void osgi::BundleContext::addBundleListener </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(R::*)(const BundleEvent)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified <code>callback</code> to the context modules's list of listeners. </p>
<p>Listeners are notified when a bundle has a lifecycle state change.</p>
<p>If the context bundle's list of listeners already contains a pair <code>(r,c)</code> of <code>receiver</code> and <code>callback</code> such that <code>(r == receiver &amp;&amp; c == callback)</code>, then this method does nothing.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type of the receiver (containing the member function to be called) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>The object to connect to. </td></tr>
    <tr><td class="paramname">callback</td><td>The member function pointer to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd>BundleEvent </dd></dl>

</div>
</div>
<a class="anchor" id="ad47aca3dbd73188548a188893b71533c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osgi::BundleContext::addFrameworkListener </td>
          <td>(</td>
          <td class="paramtype">const FrameworkListener &amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified <code>FrameworkListener</code> object to the context bundle's list of listeners if not already present. </p>
<p>FrameworkListeners are notified of general Framework events.</p>
<p>If the context bundle's list of listeners already contains a listener <code>l</code> such that <code></code>(l==listener), this method does nothing.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The <code>FrameworkListener</code> object to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd>FrameworkEvent </dd>
<dd>
FrameworkListener </dd></dl>

</div>
</div>
<a class="anchor" id="a65442692af69428d5173a09f2ba62f4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void osgi::BundleContext::addServiceListener </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(R::*)(const ServiceEvent)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified <code>callback</code> with the specified <code>filter</code> to the context modules's list of listeners. </p>
<p>See LDAPFilter for a description of the filter syntax. Listeners are notified when a service has a lifecycle state change.</p>
<p>You must take care to remove registered listeners befor the <code>receiver</code> object is destroyed. However, the Framework takes care of removing all listeners registered by this context bundle's classes after the bundle is unloaded.</p>
<p>If the context bundle's list of listeners already contains a pair <code>(r,c)</code> of <code>receiver</code> and <code>callback</code> such that <code>(r == receiver &amp;&amp; c == callback)</code>, then this method replaces that callback's filter (which may be empty) with the specified one (which may be empty).</p>
<p>The callback is called if the filter criteria is met. To filter based upon the class of the service, the filter should reference the <a class="el" href="structosgi_1_1Constants.html#a14e1193832f8ca68e5cba59627cc9db2" title="Service property identifying all of the class names under which a service was registered in the Frame...">Constants::OBJECTCLASS()</a> property. If <code>filter</code> is empty, all services are considered to match the filter.</p>
<p>When using a <code>filter</code>, it is possible that the <code>ServiceEvent</code>s for the complete lifecycle of a service will not be delivered to the callback. For example, if the <code>filter</code> only matches when the property <code>x</code> has the value <code>1</code>, the callback will not be called if the service is registered with the property <code>x</code> not set to the value <code>1</code>. Subsequently, when the service is modified setting property <code>x</code> to the value <code>1</code>, the filter will match and the callback will be called with a <code>ServiceEvent</code> of type <code>MODIFIED</code>. Thus, the callback will not be called with a <code>ServiceEvent</code> of type <code>REGISTERED</code>.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type of the receiver (containing the member function to be called) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>The object to connect to. </td></tr>
    <tr><td class="paramname">callback</td><td>The member function pointer to call. </td></tr>
    <tr><td class="paramname">filter</td><td>The filter criteria. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classosgi_1_1InvalidSyntaxException.html" title="A Framework exception used to indicate that a filter string has an invalid syntax.">InvalidSyntaxException</a></td><td>If <code>filter</code> contains an invalid filter string that cannot be parsed. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd>ServiceEvent </dd>
<dd>
RemoveServiceListener() </dd></dl>

</div>
</div>
<a class="anchor" id="a30c73dd987bb80692247493bd5d264cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Filter osgi::BundleContext::createFilter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <code>Filter</code> object. </p>
<p>This <code>Filter</code> object may be used to match a <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object or a <code>Dictionary</code> object.</p>
<p>If the filter cannot be parsed, an <a class="el" href="classosgi_1_1InvalidSyntaxException.html">InvalidSyntaxException</a> will be thrown with a human readable message where the filter became unparsable.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>The filter string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A <code>Filter</code> object encapsulating the filter string. </dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classosgi_1_1InvalidSyntaxException.html" title="A Framework exception used to indicate that a filter string has an invalid syntax.">InvalidSyntaxException</a></td><td>If <code>filter</code> contains an invalid filter string that cannot be parsed. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>If <code>filter</code> is null. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd>"Framework specification for a description of the filter string syntax." </dd>
<dd>
FrameworkUtil::createFilter(String) </dd></dl>

</div>
</div>
<a class="anchor" id="abe59b6310c208d4e5bbd2b695ce34246"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Bundle* osgi::BundleContext::getBundle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>IBundle</code> object associated with this <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code>. </p>
<p>This bundle is called the context bundle. </p>
<pre class="fragment">@return The &lt;code&gt;IBundle&lt;/code&gt; object associated with this
        &lt;code&gt;BundleContext&lt;/code&gt;.
@throws IllegalStateException If this BundleContext is no
        longer valid.</pre> 
</div>
</div>
<a class="anchor" id="a72291aae38791624b682038e50768a16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Bundle* osgi::BundleContext::getBundle </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bundle with the specified identifier. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The identifier of the bundle to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A <code>IBundle</code> object or <code>NULL</code> if the identifier does not match any previously loaded bundle. </dd></dl>

</div>
</div>
<a class="anchor" id="a50bad0aa626362bd9355a9755b5d6356"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Bundle* osgi::BundleContext::getBundle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bundle with the specified location. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the bundle to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A <code>Bundle</code> object or <code>null</code> if the location does not match any installed bundle. </dd></dl>

</div>
</div>
<a class="anchor" id="a510548621888bb4b545fccfd8ba2f326"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;Bundle*&gt; osgi::BundleContext::getBundles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all known modules. </p>
<p>This method returns a list of all modules loaded in the bundle environment at the time of the call to this method. This list will also contain modules which might already have been unloaded.</p>
<dl class="section return"><dt>Returns:</dt><dd>A std::vector of <code>Bundle</code> objects which will hold one object per known bundle. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8ee6af9a244fa2bfefa03efb9d4aba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string osgi::BundleContext::getDataFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a string containing the location for a file in the persistent storage area provided for the bundle by the Framework. </p>
<p>This method will return an empty string if the platform does not have file system support.</p>
<p>A string containing the location for the base directory of the persistent storage area provided for the context bundle by the Framework can be obtained by calling this method with an empty string as <code>filename</code>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A relative name to the file to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A <code>std::string</code> object that represents the requested file or an empty string if the platform does not have file system support. </dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3171cf4700e41eae44882bfc1d71e96a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string osgi::BundleContext::getProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the specified property. </p>
<p>If the key is not found in the Framework properties, the system properties are then searched. The method returns <code>null</code> if the property is not found.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the requested property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The value of the requested property, or <code>null</code> if the property is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4a9d783b04e42c0e960fefde434591b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">S* osgi::BundleContext::getService </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classosgi_1_1ServiceReference.html">ServiceReference</a>&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the service object referenced by the specified <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object. </p>
<p>A bundle's use of a service is tracked by the bundle's use count of that service. Each time a service's service object is returned by <a class="el" href="structosgi_1_1BundleContext.html#ad4a9d783b04e42c0e960fefde434591b" title="Returns the service object referenced by the specified ServiceReference object.">getService&lt;S&gt;(const ServiceReference&lt;S&gt;&amp;)</a> the context bundle's use count for that service is incremented by one. Each time the service is released by ungetService(const ServiceReferenceBase&amp;) the context bundle's use count for that service is decremented by one. </p>
<p>When a bundle's use count for a service drops to zero, the bundle should no longer use that service.</p>
<p>This method will always return <code>NULL</code> when the service associated with this <code>reference</code> has been unregistered.</p>
<p>The following steps are required to get the service object: </p>
<ol>
<li>
If the service has been unregistered, <code>NULL</code> is returned. </li>
<li>
If the context bundle's use count for the service is currently zero and the service was registered with an object implementing the <code>ServiceFactory</code> interface, the <a class="el" href="">ServiceFactory#getService(Bundle, ServiceRegistration)</a> method is called to create a service object for the context bundle. If the service object returned by the <code>ServiceFactory</code> object is <code>NULL</code>, not an instance of all the classes named when the service was registered or the <code>ServiceFactory</code> object throws an exception or will be recursively called for the context bundle, <code>NULL</code> is returned and a Framework event of type <a class="el" href="">FrameworkEvent#ERROR</a> containing a <a class="el" href="classosgi_1_1ServiceException.html">ServiceException</a> describing the error is fired. <br/>
 This service object is cached by the Framework. While the context bundle's use count for the service is greater than zero, subsequent calls to get the services's service object for the context bundle will return the cached service object. </li>
<li>
The context bundle's use count for this service is incremented by one. </li>
<li>
The service object for the service is returned. </li>
</ol>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>Type of Service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>A reference to the service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A service object for the service associated with <code>reference</code> or <code>NULL</code> if the service is not registered, the service object returned by a <code>ServiceFactory</code> does not implement the classes under which it was registered or the <code>ServiceFactory</code> threw an exception. </dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname">InvalidArgumentException</td><td>If the specified <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> was not created by the same framework instance as this <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd>ungetService(const ServiceReferenceBase&amp;) </dd>
<dd>
ServiceFactory </dd></dl>

</div>
</div>
<a class="anchor" id="a4925e35fd2eb059fe7e35ae15a1802ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classosgi_1_1ServiceReference.html">ServiceReference</a>&lt;void&gt; osgi::BundleContext::getServiceReference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clazz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cppOnly</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code><a class="el" href="classosgi_1_1ServiceReferenceBase.html" title="A reference to a service.">ServiceReferenceBase</a></code> object for a service that implements and was registered under the specified class. </p>
<p>The returned <code><a class="el" href="classosgi_1_1ServiceReferenceBase.html" title="A reference to a service.">ServiceReferenceBase</a></code> object is valid at the time of the call to this method. However as the Framework is a very dynamic environment, services can be modified or unregistered at any time.</p>
<p>This method is the same as calling <a class="el" href="structosgi_1_1BundleContext.html#ac2a29655ce5f9a3b78193a1beb9b3cab">BundleContext::getServiceReferences(const std::string&amp;, const std::string&amp;)</a> with an empty filter expression. It is provided as a convenience for when the caller is interested in any service that implements the specified class. </p>
<p>If multiple such services exist, the service with the highest ranking (as specified in its <a class="el" href="structosgi_1_1Constants.html#ad5fcf12b428f2e3f37fa40f035c014d1" title="Service property identifying a service&#39;s ranking number.">Constants::SERVICE_RANKING()</a> property) is returned. </p>
<p>If there is a tie in ranking, the service with the lowest service ID (as specified in its <a class="el" href="structosgi_1_1Constants.html#abbbd9587b6ee91543f4214877889701f" title="Service property identifying a service&#39;s registration number.">Constants::SERVICE_ID()</a> property); that is, the service that was registered first is returned.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">clazz</td><td>The class name with which the service was registered. </td></tr>
    <tr><td class="paramname">cppOnly</td><td>If <code>true</code>, get a reference to a C++ service. Get a C service reference otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A <code><a class="el" href="classosgi_1_1ServiceReferenceBase.html" title="A reference to a service.">ServiceReferenceBase</a></code> object, or an invalid <code><a class="el" href="classosgi_1_1ServiceReferenceBase.html" title="A reference to a service.">ServiceReferenceBase</a></code> if no services are registered which implement the named class. </dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classosgi_1_1ServiceException.html" title="A service exception used to indicate that a service problem occurred.">ServiceException</a></td><td>If no service was registered under the given class name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="structosgi_1_1BundleContext.html#ac2a29655ce5f9a3b78193a1beb9b3cab" title="Returns a list of ServiceReferenceBase objects.">getServiceReferences(const std::string&amp;, const std::string&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac7ecad76ec321f8eebd850cda36eedff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classosgi_1_1ServiceReference.html">ServiceReference</a>&lt;S&gt; osgi::BundleContext::getServiceReference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object for a service that implements and was registered under the specified type. </p>
<p>The returned <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object is valid at the time of the call to this method. However as the Framework is a very dynamic environment, services can be modified or unregistered at any time.</p>
<p>This method is the same as calling <a class="el" href="structosgi_1_1BundleContext.html#ac2a29655ce5f9a3b78193a1beb9b3cab">&lt;S&gt;(std::string)</a> with an empty filter expression and then finding the reference with the highest priority. It is provided as a convenience for when the caller is interested in any service that implements the specified class. </p>
<p>If multiple such services exist, the service with the highest priority is selected. This priority is defined as the service reference with the highest ranking (as specified in its <a class="el" href="structosgi_1_1Constants.html#ad5fcf12b428f2e3f37fa40f035c014d1">Constants#SERVICE_RANKING</a> property) is returned. </p>
<p>If there is a tie in ranking, the service with the lowest service ID (as specified in its <a class="el" href="structosgi_1_1Constants.html#abbbd9587b6ee91543f4214877889701f">Constants#SERVICE_ID</a> property); that is, the service that was registered first is returned.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The type with which the service was registered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object. The returned object is invalid if no services are registered which implement the given type. </dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="structosgi_1_1BundleContext.html#ac2a29655ce5f9a3b78193a1beb9b3cab" title="Returns a list of ServiceReferenceBase objects.">getServiceReferences</a>&lt;S&gt;(std::string) </dd></dl>

</div>
</div>
<a class="anchor" id="ac2a29655ce5f9a3b78193a1beb9b3cab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="classosgi_1_1ServiceReference.html">ServiceReference</a>&lt;void&gt; &gt; osgi::BundleContext::getServiceReferences </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clazz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of <code><a class="el" href="classosgi_1_1ServiceReferenceBase.html" title="A reference to a service.">ServiceReferenceBase</a></code> objects. </p>
<p>The returned list contains services that were registered under the specified class and match the specified filter expression.</p>
<p>The list is valid at the time of the call to this method. However since the Framework is a very dynamic environment, services can be modified or unregistered at any time.</p>
<p>The specified <code>filter</code> expression is used to select the registered services whose service properties contain keys and values which satisfy the filter expression. See LDAPFilter for a description of the filter syntax. If the specified <code>filter</code> is empty, all registered services are considered to match the filter. If the specified <code>filter</code> expression cannot be parsed, an <code>std::invalid_argument</code> will be thrown with a human readable message where the filter became unparsable.</p>
<p>The result is a list of <code><a class="el" href="classosgi_1_1ServiceReferenceBase.html" title="A reference to a service.">ServiceReferenceBase</a></code> objects for all services that meet all of the following conditions: </p>
<ul>
<li>
If the specified class name, <code>clazz</code>, is not empty, the service must have been registered with the specified class name. The complete list of class names with which a service was registered is available from the service's <a class="el" href="structosgi_1_1Constants.html#a14e1193832f8ca68e5cba59627cc9db2">objectClass</a> property. </li>
<li>
If the specified <code>filter</code> is not empty, the filter expression must match the service. </li>
</ul>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">clazz</td><td>The class name with which the service was registered or an empty string for all services. </td></tr>
    <tr><td class="paramname">filter</td><td>The filter expression or empty for all services. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A list of <code><a class="el" href="classosgi_1_1ServiceReferenceBase.html" title="A reference to a service.">ServiceReferenceBase</a></code> objects or an empty list if no services are registered which satisfy the search. </dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidArgumentException</td><td>If the specified <code>filter</code> contains an invalid filter expression that cannot be parsed. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6326ddaefa00ea65495cd45694f408e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classosgi_1_1ServiceReference.html">ServiceReference</a>&lt;S&gt; &gt; osgi::BundleContext::getServiceReferences </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>std::string()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects. </p>
<p>The returned array of <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects contains services that were registered under the specified class and match the specified filter expression.</p>
<p>The list is valid at the time of the call to this method. However since the Framework is a very dynamic environment, services can be modified or unregistered at any time.</p>
<p>The specified <code>filter</code> expression is used to select the registered services whose service properties contain keys and values which satisfy the filter expression. See <a class="el" href="">Filter</a> for a description of the filter syntax. If the specified <code>filter</code> is <code>null</code>, all registered services are considered to match the filter. If the specified <code>filter</code> expression cannot be parsed, an <a class="el" href="classosgi_1_1InvalidSyntaxException.html">InvalidSyntaxException</a> will be thrown with a human readable message where the filter became unparsable.</p>
<p>The result is an array of <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects for all services that meet all of the following conditions: </p>
<ul>
<li>
If the specified class name, <code>clazz</code>, is not <code>null</code>, the service must have been registered with the specified class name. The complete list of class names with which a service was registered is available from the service's <a class="el" href="structosgi_1_1Constants.html#a14e1193832f8ca68e5cba59627cc9db2">objectClass</a> property. </li>
<li>
If the specified <code>filter</code> is not empty, the filter expression must match the service. </li>
</ul>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The type with which the service was registered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>The filter expression or <code>empty</code> for all services. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>An array of <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects. </dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classosgi_1_1InvalidSyntaxException.html" title="A Framework exception used to indicate that a filter string has an invalid syntax.">InvalidSyntaxException</a></td><td>If the specified <code>filter</code> contains an invalid filter expression that cannot be parsed. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9ad5fb869062ed85aff154fcd25e63e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Bundle* osgi::BundleContext::installBundle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>input</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Installs a bundle from the specified <code>std::istream</code> object. </p>
<p>If the specified <code>std::istream</code> is <code>NULL</code>, the Framework must create the <code>std::istream</code> from which to read the bundle by interpreting, in an implementation dependent manner, the specified <code>location</code>.</p>
<p>The specified <code>location</code> identifier will be used as the identity of the bundle. Every installed bundle is uniquely identified by its location identifier which is typically in the form of a URL.</p>
<p>The following steps are required to install a bundle: </p>
<ol>
<li>
<p class="startli">If a bundle containing the same location identifier is already installed, the <code>Bundle</code> object for that bundle is returned.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The bundle's content is read from the input stream. If this fails, a <a class="el" href="classosgi_1_1BundleException.html">BundleException</a> is thrown.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The bundle's associated resources are allocated. The associated resources minimally consist of a unique identifier and a persistent storage area if the platform has file system support. If this step fails, a <code><a class="el" href="classosgi_1_1BundleException.html" title="A Framework exception used to indicate that a bundle lifecycle problem occurred.">BundleException</a></code> is thrown.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The bundle's state is set to <code>INSTALLED</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A bundle event of type <a class="el" href="">BundleEvent#INSTALLED</a> is fired.</p>
<p class="endli"></p>
</li>
<li>
The <code>Bundle</code> object for the newly or previously installed bundle is returned. </li>
</ol>
<p><b>Postconditions, no exceptions thrown </b> </p>
<ul>
<li>
<code>getState()</code> in { <code>INSTALLED</code>, <code>RESOLVED</code> } </li>
<li>
Bundle has a unique ID. </li>
</ul>
<p><b>Postconditions, when an exception is thrown </b> </p>
<ul>
<li>
Bundle is not installed. If there was an existing bundle for the specified location, then that bundle must still be in the state it was prior to calling this method. </li>
</ul>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location identifier of the bundle to install. </td></tr>
    <tr><td class="paramname">input</td><td>The <code>std::istream</code> object from which this bundle will be read or <code>NULL</code> to indicate the Framework must create the input stream from the specified location identifier. The input stream must always be closed when this method completes, even if an exception is thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The <code>Bundle</code> object of the installed bundle. </dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classosgi_1_1BundleException.html" title="A Framework exception used to indicate that a bundle lifecycle problem occurred.">BundleException</a></td><td>If the installation failed. <a class="el" href="classosgi_1_1BundleException.html" title="A Framework exception used to indicate that a bundle lifecycle problem occurred.">BundleException</a> types thrown by this method include: <a class="el" href="classosgi_1_1BundleException.html#a88c99258a06f4a2c6148cbd945dca8a5aa470950f56afa5a9508cd1d3b0e856d4">BundleException#READ_ERROR</a> , <a class="el" href="classosgi_1_1BundleException.html#a88c99258a06f4a2c6148cbd945dca8a5a5549d9087ff92c98a5ee40130b51717c">BundleException#DUPLICATE_BUNDLE_ERROR</a>, <a class="el" href="classosgi_1_1BundleException.html#a88c99258a06f4a2c6148cbd945dca8a5a685bc04a75c943b556ad8ab94fa6a172">BundleException#MANIFEST_ERROR</a>, and <a class="el" href="classosgi_1_1BundleException.html#a88c99258a06f4a2c6148cbd945dca8a5aeb9b44890d73da27abde6781a57e1913">BundleException#REJECTED_BY_HOOK</a>. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e036a67a3a0b85601f00abffa7ce84a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classosgi_1_1ServiceRegistrationBase.html">ServiceRegistrationBase</a> osgi::BundleContext::registerService </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isNativeCpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpp__api.html#gab0aeecec02de2f46dd69e0cad120ee94">ServiceProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers the specified service object with the specified properties under the specified class names into the framework. </p>
<p>A <code><a class="el" href="classosgi_1_1ServiceRegistrationBase.html" title="A registered service.">ServiceRegistrationBase</a></code> object is returned. The <code><a class="el" href="classosgi_1_1ServiceRegistrationBase.html" title="A registered service.">ServiceRegistrationBase</a></code> object is for the private use of the bundle registering the service and should not be shared with other modules. The registering bundle is defined to be the context bundle. Other modules can locate the service by using either the <a class="el" href="structosgi_1_1BundleContext.html#ac2a29655ce5f9a3b78193a1beb9b3cab">getServiceReferences</a> or <a class="el" href="structosgi_1_1BundleContext.html#a4925e35fd2eb059fe7e35ae15a1802ad">getServiceReference</a> method.</p>
<p>A bundle can register a service object that implements the <a class="el" href="">ServiceFactory</a> interface to have more flexibility in providing service objects to other modules.</p>
<p>The following steps are taken when registering a service: </p>
<ol>
<li>
The framework adds the following service properties to the service properties from the specified <code>ServiceProperties</code> (which may be omitted): <br/>
 A property named <a class="el" href="structosgi_1_1Constants.html#abbbd9587b6ee91543f4214877889701f" title="Service property identifying a service&#39;s registration number.">Constants::SERVICE_ID()</a> identifying the registration number of the service <br/>
 A property named <a class="el" href="structosgi_1_1Constants.html#a14e1193832f8ca68e5cba59627cc9db2" title="Service property identifying all of the class names under which a service was registered in the Frame...">Constants::OBJECTCLASS()</a> containing all the specified classes. <br/>
 Properties with these names in the specified <code>ServiceProperties</code> will be ignored. </li>
<li>
The service is added to the framework service registry and may now be used by other modules. </li>
<li>
A service event of type <a class="el" href="">ServiceEvent#REGISTERED</a> is fired. </li>
<li>
A <code><a class="el" href="classosgi_1_1ServiceRegistrationBase.html" title="A registered service.">ServiceRegistrationBase</a></code> object for this registration is returned. </li>
</ol>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">clazzes</td><td>The class names under which the service can be located. The class names will be stored in the service's properties under the key <a class="el" href="structosgi_1_1Constants.html#a14e1193832f8ca68e5cba59627cc9db2" title="Service property identifying all of the class names under which a service was registered in the Frame...">Constants::OBJECTCLASS()</a>. </td></tr>
    <tr><td class="paramname">service</td><td>The service object or a <code>ServiceFactory</code> object. </td></tr>
    <tr><td class="paramname">properties</td><td>The properties for this service. The keys in the properties object must all be <code>std::string</code> objects. See <a class="el" href="structosgi_1_1Constants.html">Constants</a> for a list of standard service property keys. Changes should not be made to this object after calling this method. To update the service's properties the <a class="el" href="classosgi_1_1ServiceRegistrationBase.html#a4238402e77b1f2f41d33f5e8a60f3243">ServiceRegistration::setProperties</a> method must be called. The set of properties may be omitted if the service has no properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A <code><a class="el" href="classosgi_1_1ServiceRegistration.html" title="A registered service.">ServiceRegistration</a></code> object for use by the bundle registering the service to update the service's properties or to unregister the service. </dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidArgumentException</td><td>If one of the following is true: <ul>
<li>
<code>service</code> is <code>0</code>. </li>
<li>
<code>properties</code> contains case variants of the same key name. </li>
</ul>
</td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classosgi_1_1ServiceRegistration.html" title="A registered service.">ServiceRegistration</a> </dd>
<dd>
ServiceFactory </dd></dl>

</div>
</div>
<a class="anchor" id="a715658d1655dd0a9ed089b7e3f095539"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classosgi_1_1ServiceRegistration.html">ServiceRegistration</a>&lt;S&gt; osgi::BundleContext::registerService </td>
          <td>(</td>
          <td class="paramtype">S *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpp__api.html#gab0aeecec02de2f46dd69e0cad120ee94">ServiceProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em> = <code><a class="el" href="group__cpp__api.html#gab0aeecec02de2f46dd69e0cad120ee94">ServiceProperties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the specified service object with the specified properties under the specified template argument type into the Framework. </p>
<p>A <code><a class="el" href="classosgi_1_1ServiceRegistration.html" title="A registered service.">ServiceRegistration</a></code> object is returned. The <code><a class="el" href="classosgi_1_1ServiceRegistration.html" title="A registered service.">ServiceRegistration</a></code> object is for the private use of the bundle registering the service and should not be shared with other bundles. The registering bundle is defined to be the context bundle. Other bundles can locate the service by using either the <a class="el" href="structosgi_1_1BundleContext.html#ac2a29655ce5f9a3b78193a1beb9b3cab">getServiceReferences</a> or <a class="el" href="structosgi_1_1BundleContext.html#a4925e35fd2eb059fe7e35ae15a1802ad">getServiceReference</a> method.</p>
<p>A bundle can register a service object that implements the <a class="el" href="">ServiceFactory</a> interface to have more flexibility in providing service objects to other bundles.</p>
<p>The following steps are required to register a service: </p>
<ol>
<li>
If <code>service</code> is not a <code>ServiceFactory</code>, an <code>InvalidArgumentException</code> is thrown if <code>service</code> is not an <code>instanceof</code> all the specified class names. </li>
<li>
The Framework adds the following service properties to the service properties from the specified <code>ServiceProperties</code> (which may be <code>null</code>): <br/>
 A property named <a class="el" href="structosgi_1_1Constants.html#abbbd9587b6ee91543f4214877889701f">Constants#SERVICE_ID</a> identifying the registration number of the service <br/>
 A property named <a class="el" href="structosgi_1_1Constants.html#a14e1193832f8ca68e5cba59627cc9db2">Constants#OBJECTCLASS</a> containing all the specified classes. <br/>
 Properties with these names in the specified <code>ServiceProperties</code> will be ignored. </li>
<li>
The service is added to the Framework service registry and may now be used by other bundles. </li>
<li>
A service event of type <a class="el" href="">ServiceEvent#REGISTERED</a> is fired. </li>
<li>
A <code><a class="el" href="classosgi_1_1ServiceRegistration.html" title="A registered service.">ServiceRegistration</a></code> object for this registration is returned. </li>
</ol>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">clazzes</td><td>The class names under which the service can be located. The class names in this array will be stored in the service's properties under the key <a class="el" href="structosgi_1_1Constants.html#a14e1193832f8ca68e5cba59627cc9db2">Constants#OBJECTCLASS</a>. </td></tr>
    <tr><td class="paramname">service</td><td>The service object or a <code>ServiceFactory</code> object. </td></tr>
    <tr><td class="paramname">properties</td><td>The properties for this service. The keys in the properties object must all be <code>String</code> objects. See <a class="el" href="structosgi_1_1Constants.html">Constants</a> for a list of standard service property keys. Changes should not be made to this object after calling this method. To update the service's properties the <a class="el" href="classosgi_1_1ServiceRegistrationBase.html#a4238402e77b1f2f41d33f5e8a60f3243">ServiceRegistration#setProperties</a> method must be called. The set of properties may be <code>null</code> if the service has no properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A <code><a class="el" href="classosgi_1_1ServiceRegistration.html" title="A registered service.">ServiceRegistration</a></code> object for use by the bundle registering the service to update the service's properties or to unregister the service. </dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidArgumentException</td><td>If one of the following is true: <ul>
<li>
<code>service</code> is <code>null</code>. </li>
<li>
<code>service</code> is not a <code>ServiceFactory</code> object and is not an instance of all the named classes in <code>clazzes</code>. </li>
<li>
<code>properties</code> contains case variants of the same key name. </li>
</ul>
</td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classosgi_1_1ServiceRegistration.html" title="A registered service.">ServiceRegistration</a> </dd>
<dd>
ServiceFactory </dd></dl>

</div>
</div>
<a class="anchor" id="a93e7f266d9edcf770a628ef79bdbc1a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void osgi::BundleContext::removeBundleListener </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(R::*)(const BundleEvent)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified <code>callback</code> from the context bundle's list of listeners. </p>
<p>If the <code>(receiver,callback)</code> pair is not contained in this context bundle's list of listeners, this method does nothing.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type of the receiver (containing the member function to be removed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>The object from which to disconnect. </td></tr>
    <tr><td class="paramname">callback</td><td>The member function pointer to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd>AddBundleListener() </dd></dl>

</div>
</div>
<a class="anchor" id="aba49128a2ccfdc0184b4ff5becb081d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void osgi::BundleContext::removeFrameworkListener </td>
          <td>(</td>
          <td class="paramtype">const FrameworkListener &amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the specified <code>FrameworkListener</code> object from the context bundle's list of listeners. </p>
<p>If <code>listener</code> is not contained in the context bundle's list of listeners, this method does nothing.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The <code>FrameworkListener</code> object to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd74b1d2f53e70de60ae67d5af474a93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void osgi::BundleContext::removeServiceListener </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(R::*)(const ServiceEvent)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified <code>callback</code> from the context bundle's list of listeners. </p>
<p>If the <code>(receiver,callback)</code> pair is not contained in this context bundle's list of listeners, this method does nothing.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type of the receiver (containing the member function to be removed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>The object from which to disconnect. </td></tr>
    <tr><td class="paramname">callback</td><td>The member function pointer to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd>AddServiceListener() </dd></dl>

</div>
</div>
<a class="anchor" id="ae551559d87c4f9231e12f85d3c5772d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool osgi::BundleContext::ungetService </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classosgi_1_1ServiceReferenceBase.html">ServiceReferenceBase</a> &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the service object referenced by the specified <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object. </p>
<p>If the context bundle's use count for the service is zero, this method returns <code>false</code>. Otherwise, the context modules's use count for the service is decremented by one.</p>
<p>The service's service object should no longer be used and all references to it should be destroyed when a bundle's use count for the service drops to zero.</p>
<p>The following steps are taken to unget the service object: </p>
<ol>
<li>
If the context bundle's use count for the service is zero or the service has been unregistered, <code>false</code> is returned. </li>
<li>
The context bundle's use count for this service is decremented by one. </li>
<li>
If the context bundle's use count for the service is currently zero and the service was registered with a <code>ServiceFactory</code> object, the ServiceFactory::UngetService method is called to release the service object for the context bundle. </li>
<li>
<code>true</code> is returned. </li>
</ol>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>A reference to the service to be released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd><code>false</code> if the context bundle's use count for the service is zero or if the service has been unregistered; <code>true</code> otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>If this <a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname">InvalidArgumentException</td><td>If the specified <code><a class="el" href="classosgi_1_1ServiceReference.html" title="A reference to a service.">ServiceReference</a></code> was not created by the same framework instance as this <code><a class="el" href="structosgi_1_1BundleContext.html" title="A bundle&#39;s execution context within the framework.">BundleContext</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd>getService&lt;S&gt; </dd>
<dd>
ServiceFactory </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>/home/sascha/git/NativeOSGi/src/api/cpp/include/osgi/<a class="el" href="BundleContext_8h_source.html">BundleContext.h</a></li>
<li>/home/sascha/git/NativeOSGi/src/api/cpp/src/BundleContext.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>osgi</b></li><li class="navelem"><a class="el" href="structosgi_1_1BundleContext.html">BundleContext</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>
